<!DOCTYPE html>
<html lang="en" style="direction:ltr;">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Interactive Exam • Glowing Dark Theme</title>
<meta name="color-scheme" content="dark" />
<style>
  :root{
    --bg:#0b0b12;
    --text:#f6f7fb;
    --muted:#a6afc6;
    --card:rgba(255,255,255,0.05);
    --card-border:rgba(255,255,255,0.12);
    --glass:rgba(255,255,255,0.04);
    --glass-border:rgba(255,255,255,0.10);
    --glow-cyan:#06b6d4;
    --glow-cyan-outer:rgba(6,182,212,0.40);
    --glow-purple:#8b5cf6;
    --glow-purple-outer:rgba(139,92,246,0.35);
    --white-haze:rgba(255,255,255,0.08);
    --white-outer:rgba(255,255,255,0.15);
    --radius:16px;
    --gap:1.25rem;
    --pad:1.5rem;
    --ok:#22c55e;  /* green */
    --bad:#ef4444; /* red */
  }

  *{box-sizing:border-box}
  body{margin:0;font:16px/1.65 Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;color:var(--text);background:var(--bg);min-height:100dvh;}
  .wrap{max-width:1100px;margin:0 auto;padding:24px;}

  .titlebar{
    position:sticky;top:0;z-index:10;
    backdrop-filter:saturate(140%) blur(8px);
    background:linear-gradient(180deg,rgba(11,11,18,0.75),rgba(11,11,18,0.35));
    border-bottom:1px solid var(--glass-border);
  }
  .titlebar .inner{max-width:1100px;margin:0 auto;padding:16px 24px;display:grid;gap:8px;align-items:center;}
  .grad-text{
    font-weight:800;
    letter-spacing:.3px;
    background:linear-gradient(90deg,var(--glow-cyan),var(--glow-purple));
    -webkit-background-clip:text;background-clip:text;color:transparent;
    text-shadow:0 0 10px var(--glow-cyan-outer), 0 0 14px var(--glow-purple-outer);
  }
  h1.grad-text{font-size:clamp(1.6rem,2vw+1rem,2.6rem);margin:0;text-align:center;}
  .subtitle{margin:0;text-align:center;color:var(--muted);font-size:0.95rem}

  .section-h{
    margin:28px 0 14px;
    padding:12px 16px;
    border-radius:var(--radius);
    background:var(--glass);
    border:1px solid var(--glass-border);
    box-shadow: 0 2px 10px var(--white-haze), 0 0 18px rgba(255,255,255,0.06), 0 0 30px var(--white-outer);
    text-align:center;
    font-weight:750;
    font-size:1.15rem;
  }
  .section-h .grad-text{font-size:1.3rem;}

  .grid{display:grid;gap:var(--gap)}
  @media (min-width:800px){
    .grid.mcq{grid-template-columns:repeat(2,minmax(0,1fr));}
    .grid.tf {grid-template-columns:repeat(3,minmax(0,1fr));}
  }

  /* Cards (no accent on the card itself) */
  .card{
    background:var(--card);
    border:1px solid var(--card-border);
    border-radius:var(--radius);
    padding:var(--pad);
    box-shadow: 0 2px 8px var(--white-haze), 0 0 0 1px rgba(255,255,255,0.02), 0 0 24px rgba(255,255,255,0.06);
    position:relative;
  }

  .qtitle{font-weight:650;margin:0 0 12px}
  .meta{color:var(--muted);font-size:0.88rem;margin-bottom:10px}

  .opts{display:grid;gap:10px}
  .opt-btn{
    all:unset;cursor:pointer;display:flex;gap:10px;align-items:center;
    padding:12px 14px;border-radius:12px;
    background:rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.10);
    transition:transform .06s ease, background .15s ease, border-color .15s ease;
  }
  .opt-btn .key{width:28px;height:28px;border-radius:9px;display:grid;place-items:center;font-weight:700;
    background:linear-gradient(90deg,var(--glow-cyan),var(--glow-purple));color:#0b0b12;
    box-shadow:0 0 10px var(--glow-cyan-outer),0 0 10px var(--glow-purple-outer) inset;
  }
  .opt-btn:hover{transform:translateY(-1px);border-color:rgba(255,255,255,0.22);}

  /* Accent line ONLY on the chosen/correct answer box, no background highlight */
  .opt-btn.correct{
    border-left:6px solid var(--ok);
    outline:none;
    background:rgba(255,255,255,0.03);
  }
  .opt-btn.wrong{
    border-left:6px solid var(--bad);
    outline:none;
    background:rgba(255,255,255,0.03);
  }
  .opt-btn[disabled]{opacity:.85;cursor:not-allowed;pointer-events:none;}

  .feedback{margin-top:10px;border-radius:12px;padding:10px 12px;border:1px dashed rgba(255,255,255,0.18);background:rgba(255,255,255,0.03);color:var(--muted);} 
  .feedback[hidden]{display:none;}
  .feedback b{color:var(--text)}

  .answer{margin-top:10px;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.04)}
  .answer[hidden]{display:none;}
  .btnrow{display:flex;gap:10px;flex-wrap:wrap}
  .ghost, .primary{
    all:unset;cursor:pointer;border-radius:12px;padding:10px 14px;font-weight:650;border:1px solid rgba(255,255,255,0.18);
    background:rgba(255,255,255,0.03);
  }
  .primary{background:linear-gradient(90deg,var(--glow-cyan),var(--glow-purple));color:#0b0b12;border-color:transparent;}

  .score{
    margin:16px 0;padding:12px 14px;border-radius:14px;
    background:var(--glass);border:1px solid var(--glass-border);box-shadow: 0 2px 10px var(--white-haze), 0 0 18px rgba(255,255,255,0.06), 0 0 30px var(--white-outer);
    display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;
  }
  .score .part{color:var(--muted);font-weight:600}
  .score b{color:var(--text)}
</style>
</head>
<body>
  <header class="titlebar">
    <div class="inner">
      <h1 class="grad-text">🦷 Dentistry 3rd year</h1>
      <p class="subtitle">Test based on Lecture 1 (by ACE)</p>
    </div>
  </header>

  <main class="wrap">

    <h2 class="section-h"><span class="grad-text">اللَّهُمَّ لا سَهْلَ إِلَّا مَا جَعَلْتَهُ سَهْلًا، وَأَنْتَ تَجْعَلُ الحَزْنَ إِذَا شِئْتَ سَهْلًا</span></h2>

    <section class="score" id="scoreTop">
      <div class="part">MCQs: <b><span id="sMcq">0</span>/30</b></div>
      <div class="part">True/False: <b><span id="sTf">0</span>/12</b></div>
      <div class="part">SAQs: <b><span id="sSaq">0</span>/3</b></div>
      <div class="part">Total: <b><span id="sTotal">0</span>/45</b></div>
      <div class="btnrow">
        <button class="ghost" id="resetAll">Reset</button>
      </div>
    </section>

    <h2 class="section-h"><span class="grad-text">MCQs</span></h2>
    <div class="grid mcq" id="mcqGrid"></div>

    <h2 class="section-h"><span class="grad-text">True / False</span></h2>
    <div class="grid tf" id="tfGrid"></div>

    <h2 class="section-h"><span class="grad-text">Short Answer Questions</span></h2>
    <div class="grid" id="saqGrid"></div>

    <section class="score" id="scoreBottom">
      <div class="part">MCQs: <b><span id="sMcq2">0</span>/30</b></div>
      <div class="part">True/False: <b><span id="sTf2">0</span>/12</b></div>
      <div class="part">SAQs: <b><span id="sSaq2">0</span>/3</b></div>
      <div class="part">Total: <b><span id="sTotal2">0</span>/45</b></div>
    </section>
  </main>

<script>
// ----------- Data (filled from lecture) -----------
const mcqs = [
  { q: "Dental caries is best defined as:", opts: [
      "An inflammatory disease limited to the gingiva.",
      "An infectious microbial disease of calcified tissues of teeth characterized by demineralization of the inorganic portion and destruction of the organic portion.",
      "A non-infectious wear process affecting only enamel.",
      "A congenital defect of enamel development."], correct: 1,
    explain: "Caries is an infectious microbial disease causing inorganic demineralization and organic matrix destruction." },
  { q: "Caries can be classified according to which three broad categories?", opts: [
      "Etiology, color, hardness",
      "Location, extent, rate",
      "Tooth type, age, gender",
      "Plaque index, saliva flow, diet"], correct: 1,
    explain: "The lecture lists location, extent, and rate (speed) of caries as the classification axes." },
  { q: "How many morphologic types of primary caries are evident clinically?", opts: ["Two","Three","Four","Five"], correct: 1,
    explain: "Three types: pit & fissure, smooth surface, and root surface caries." },
  { q: "Pit and fissure caries typically begins in:", opts: [
      "Habitually unclean smooth enamel areas",
      "Pits and fissures from imperfect coalescence of enamel lobes",
      "Exposed cementum-free root surfaces",
      "Periapical tissues"], correct: 1,
    explain: "They arise in pits/fissures formed by imperfect coalescence of enamel lobes." },
  { q: "Once pit and fissure caries reaches the DEJ, it:", opts: [
      "Slows and narrows vertically",
      "Quickly spreads laterally along the DEJ",
      "Arrests spontaneously",
      "Seals by secondary dentin formation immediately"], correct: 1,
    explain: "At the DEJ, caries rapidly spreads laterally." },
  { q: "Smooth surface caries most commonly begins in:", opts: [
      "Areas habitually unclean and continually covered by plaque",
      "Areas protected by saliva flow",
      "Areas of recent polishing",
      "Areas with deep pits"], correct: 0,
    explain: "It begins on smooth enamel surfaces that are habitually unclean and plaque covered." },
  { q: "Which statement about root surface caries is TRUE?", opts: [
      "It is slower than other forms and rarely needs early intervention.",
      "It occurs only in adolescents with intact gingiva.",
      "It may be more rapid than other forms and should be detected and treated early.",
      "It originates in enamel pits exclusively."], correct: 2,
    explain: "Root caries is usually more rapid; early detection and treatment are emphasized." },
  { q: "Why is the root surface more susceptible to demineralization than enamel?", opts: [
      "Because cementum covering the root is extremely thin and provides little resistance to caries attack.",
      "Because enamel is absent in primary teeth.",
      "Because dentin is more mineralized than enamel.",
      "Because saliva cannot reach root surfaces."], correct: 0,
    explain: "Thin cementum offers little resistance; common with gingival recession in older patients." },
  { q: "Secondary (recurrent) caries typically occurs:", opts: [
      "On sound enamel far from restorations",
      "At the junction of a restoration and tooth, potentially progressing under the restoration",
      "Only on root surfaces",
      "Only in the absence of plaque"], correct: 1,
    explain: "It occurs at restoration-tooth junctions and may progress under restorations; often linked to microleakage." },
  { q: "Incipient caries on smooth enamel appears and behaves how?", opts: [
      "Opaque white when air dried and remains white when wetted; irreversible",
      "Opaque white when air dried and disappears when wetted; potentially reversible",
      "Brown-black and hard; arrested",
      "Cavitated with exposed dentin; remineralizes readily"], correct: 1,
    explain: "Incipient lesions turn opaque on drying, fade when wet, and can remineralize with measures like fluoride and plaque control." },
  { q: "Cavitated caries is typically:", opts: [
      "An intact enamel surface treatable with fluoride only",
      "A broken enamel surface, usually into dentin; remineralization is unlikely and restoration is indicated",
      "A discoloration without structural loss",
      "A lesion limited to calculus"], correct: 1,
    explain: "Cavitated lesions have non-intact enamel and often extend into dentin, requiring restoration." },
  { q: "Acute (rampant) caries is characterized by:", opts: [
      "Slow progression and dark, hard lesions",
      "Rapid progression with soft, light-colored lesions; infectious",
      "Only root involvement",
      "Self-limiting behavior"], correct: 1,
    explain: "Acute caries progresses rapidly; lesions are soft, light colored, and infectious." },
  { q: "Chronic (arrested) caries in enamel is typically:", opts: [
      "Soft and chalky",
      "Hard, brown to black and may be more caries resistant than adjacent enamel",
      "Radiolucent and rapidly spreading",
      "White and reversible only"], correct: 1,
    explain: "Arrested lesions are hard, dark, and may become more resistant, often influenced by fluoride." },
  { q: "Forward caries refers to caries that:", opts: [
      "Extends from dentin back to enamel first",
      "Extends from pit/fissure toward DEJ then into dentin (from enamel to dentin)",
      "Moves only cervically",
      "Begins at the cementoenamel junction"], correct: 1,
    explain: "Forward caries proceeds from enamel through DEJ to dentin." },
  { q: "Backward caries describes a lesion that:", opts: [
      "After spreading laterally at the DEJ, extends back to enamel",
      "Moves apically along the root only",
      "Begins at periapex",
      "Is the same as forward caries"], correct: 0,
    explain: "Backward caries spreads laterally at DEJ and then returns toward enamel." },
  { q: "Residual caries:", opts: [
      "Is acceptable on prepared enamel walls.",
      "May be accepted as affected dentin near the pulp, but is not acceptable on the prepared enamel wall.",
      "Is always acceptable anywhere in the cavity.",
      "Refers to stained but sound enamel only."], correct: 1,
    explain: "Residual caries is unacceptable on enamel margins; affected dentin near the pulp may be left when indicated." },
  { q: "A simple tooth preparation involves:", opts: ["One surface","Two surfaces","Three surfaces","Four surfaces"], correct: 0,
    explain: "Simple = one surface involved." },
  { q: "A compound tooth preparation involves:", opts: ["One surface","Two surfaces","Three or more surfaces","Only occlusal"], correct: 1,
    explain: "Compound = two surfaces." },
  { q: "A complex tooth preparation involves:", opts: ["One surface","Exactly two surfaces","Three or more surfaces","Only anterior teeth"], correct: 2,
    explain: "Complex = three or more surfaces." },
  { q: "In G.V. Black's system, which statement is TRUE?", opts: [
      "Only Class II lesions are pit-and-fissure lesions.",
      "Class I lesions are pit-and-fissure; the remaining classes are smooth-surface lesions.",
      "All classes are smooth-surface lesions.",
      "Class VI did not exist in Black's classification."], correct: 1,
    explain: "Class I is pit-and-fissure; Classes II–VI are smooth-surface types (with Class VI added later)." },
  { q: "Which of the following is NOT a Class I location?", opts: [
      "Occlusal surfaces of premolars and molars",
      "Facial and lingual pits of molars",
      "Lingual pits of maxillary incisors",
      "Proximal surfaces of posterior teeth"], correct: 3,
    explain: "Proximal surfaces of posterior teeth are Class II, not Class I." },
  { q: "Class II preparations are located on:", opts: [
      "Proximal surfaces of posterior teeth",
      "Gingival third of facial surfaces only",
      "Incisal edges of anterior teeth",
      "Lingual pits of incisors"], correct: 0,
    explain: "Class II = proximals of posterior teeth." },
  { q: "Class III preparations involve:", opts: [
      "Proximal surfaces of anterior teeth without involving the incisal angle",
      "Proximal surfaces of anterior teeth involving the incisal angle",
      "Gingival third of any tooth",
      "Only occlusal pits"], correct: 0,
    explain: "Class III = proximals of anterior teeth that do not involve the incisal angle." },
  { q: "Class IV preparations involve:", opts: [
      "Proximal surfaces of anterior teeth that do involve the incisal angle",
      "Proximal surfaces of posterior teeth",
      "Gingival third of facial/lingual surfaces",
      "Incisal edges only without proximal involvement"], correct: 0,
    explain: "Class IV = proximals of anterior teeth with incisal angle involvement." },
  { q: "Class V preparations are located on:", opts: [
      "Occlusal cusp heights of posterior teeth",
      "Gingival third of the facial or lingual surfaces of all teeth",
      "Proximal surfaces of posterior teeth",
      "Lingual pits of maxillary incisors"], correct: 1,
    explain: "Class V = cervical/gingival third on facial or lingual of any tooth." },
  { q: "Class VI preparations are located on:", opts: [
      "Incisal edge of anterior teeth and occlusal cusp heights of posterior teeth",
      "Only root surfaces",
      "Only facial surfaces of incisors",
      "Only occlusal fossae"], correct: 0,
    explain: "Class VI = incisal edges and cusp tips." },
  { q: "An internal wall is a prepared surface that:", opts: [
      "Extends to the external tooth surface",
      "Does not extend to the external tooth surface (e.g., axial and pulpal walls)",
      "Is always at the cavosurface",
      "Is located only on roots"], correct: 1,
    explain: "Internal walls do not reach external tooth surfaces; examples are axial and pulpal walls." },
  { q: "The pulpal wall is:", opts: [
      "Parallel to the long axis of the tooth",
      "Perpendicular to the long axis of the tooth",
      "Angled at 45° to the long axis",
      "A cavosurface margin"], correct: 1,
    explain: "Pulpal wall/floor is perpendicular to the long axis." },
  { q: "The axial wall is:", opts: [
      "Perpendicular to the long axis",
      "Parallel to the long axis",
      "External tooth surface only",
      "Another term for pulpal floor"], correct: 1,
    explain: "Axial wall is an internal wall parallel to the long axis." },
  { q: "The cavosurface angle is the angle formed by:", opts: [
      "The junction of two prepared planar walls",
      "The junction of a prepared wall and the external tooth surface",
      "Three prepared walls",
      "The pulpal and axial walls only"], correct: 1,
    explain: "Cavosurface angle = prepared wall meeting external tooth surface." }
];

const tfs = [
  { q: "Primary caries is the original (first) carious lesion of the tooth.", answer: true, explain: "By definition, primary caries is the first lesion on a tooth." },
  { q: "Root surface caries is most common in younger patients with no gingival recession.", answer: false, explain: "It's more common in older patients due to gingival recession." },
  { q: "Secondary caries often indicates that microleakage is present.", answer: true, explain: "Recurrent caries at restoration margins is commonly associated with microleakage." },
  { q: "Incipient smooth-surface caries can be remineralized with corrective measures.", answer: true, explain: "Fluoride use and plaque control can remineralize incipient lesions." },
  { q: "Cavitated caries lesions are usually amenable to remineralization alone.", answer: false, explain: "They usually require preparation and restoration." },
  { q: "Acute caries produces dark, hard lesions that progress slowly.", answer: false, explain: "Acute lesions are soft, light-colored, and rapidly progressing." },
  { q: "Arrested enamel caries can become more caries resistant than adjacent unaffected enamel.", answer: true, explain: "Arrested lesions may harden and darken, becoming relatively resistant." },
  { q: "Forward caries extends from dentin to enamel before reaching the DEJ.", answer: false, explain: "Forward caries goes from enamel to DEJ then into dentin." },
  { q: "Residual caries is acceptable on prepared enamel walls.", answer: false, explain: "Residual caries on enamel margins is not acceptable." },
  { q: "Class II preparations involve proximal surfaces of anterior teeth.", answer: false, explain: "Class II involves proximals of posterior teeth; anterior proximals are Class III/IV." },
  { q: "The axial wall is perpendicular to the long axis of the tooth.", answer: false, explain: "The axial wall is parallel; the pulpal wall is perpendicular." },
  { q: "The cavosurface angle is the junction of two prepared walls only.", answer: false, explain: "That's a line angle; cavosurface is prepared wall meeting the external surface." }
];

const saqs = [
  { q: "List the three broad classifications of caries and give one example for each.", a: "(1) Location: primary (pit & fissure, smooth surface, root) vs secondary/recurrent. (2) Extent: incipient (reversible, opaque on drying) vs cavitated (non-intact enamel, into dentin). (3) Rate: acute/rampant (rapid, soft light lesions) vs chronic/arrested (hard, brown-black)." },
  { q: "Enumerate G.V. Black classes I–VI with a brief description.", a: "I: Pit & fissure (occlusal of posteriors, pits of molars, lingual pits of maxillary incisors). II: Proximal of posterior teeth. III: Proximal of anterior teeth, no incisal angle. IV: Proximal of anterior teeth, with incisal angle. V: Gingival third of facial/lingual of all teeth. VI: Incisal edge of anterior and cusp tips of posterior teeth." },
  { q: "Define pulpal wall, axial wall, and cavosurface angle.", a: "Pulpal wall (floor): internal wall perpendicular to the long axis. Axial wall: internal wall parallel to the long axis. Cavosurface angle: angle formed by the junction of a prepared wall and the external tooth surface." }
];

// ----------- State -----------
const state = {
  mcq: Array(mcqs.length).fill(null), // null | selectedIndex
  tf: Array(tfs.length).fill(null),   // null | boolean
  saq: Array(saqs.length).fill(false) // self-marked
};

function shuffleIndices(n){
  const arr = Array.from({length:n}, (_,i)=>i);
  for(let i=n-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

// ----------- Render MCQs -----------
const mcqGrid = document.getElementById('mcqGrid');
mcqs.forEach((item, idx)=>{
  const map = shuffleIndices(4);
  const visualToOriginal = map;
  const originalToVisual = Array(4);
  map.forEach((orig, v)=>{ originalToVisual[orig] = v; });
  const correctVisualIndex = originalToVisual[item.correct];

  const card = document.createElement('article');
  card.className='card qcard';
  card.dataset.type='mcq';
  card.dataset.index = idx;
  card.dataset.locked = 'false';
  card.innerHTML = `
    <p class="meta">Question ${idx+1} of ${mcqs.length}</p>
    <h3 class="qtitle">${item.q}</h3>
    <div class="opts">
      ${[0,1,2,3].map(v=>`
        <button class="opt-btn" data-v="${v}" aria-label="Answer option ${String.fromCharCode(65+v)}">
          <span class="key">${String.fromCharCode(65+v)}</span>
          <span class="label">${item.opts[ visualToOriginal[v] ]}</span>
        </button>
      `).join('')}
    </div>
    <div class="feedback" hidden></div>
  `;

  const buttons = card.querySelectorAll('.opt-btn');
  const feedback = card.querySelector('.feedback');

  function lock(){
    card.dataset.locked = 'true';
    buttons.forEach(b=>b.setAttribute('disabled',''));
  }

  buttons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if(card.dataset.locked === 'true') return; // one attempt
      const v = Number(btn.dataset.v);
      state.mcq[idx] = v;

      // clear classes
      buttons.forEach(b=>b.classList.remove('correct','wrong'));

      // Always mark the correct option (green)
      const correctBtn = buttons[correctVisualIndex];
      correctBtn.classList.add('correct');

      if(v !== correctVisualIndex){
        // Mark chosen wrong option (red)
        btn.classList.add('wrong');
        feedback.hidden=false;
        feedback.innerHTML = `<b>Wrong ✖</b><br>Correct answer: <b>${String.fromCharCode(65+correctVisualIndex)}</b><br>${item.explain}`;
      }else{
        feedback.hidden=false;
        feedback.innerHTML = `<b>Correct ✔</b><br>Answer: <b>${String.fromCharCode(65+correctVisualIndex)}</b><br>${item.explain}`;
      }
      lock();
      recalc();
    });
  });

  mcqGrid.appendChild(card);
});

// ----------- Render True/False -----------
const tfGrid = document.getElementById('tfGrid');
tfs.forEach((item, idx)=>{
  const card = document.createElement('article');
  card.className='card qcard';
  card.dataset.type='tf';
  card.dataset.index = idx;
  card.dataset.locked = 'false';
  card.innerHTML = `
    <p class="meta">Statement ${idx+1} of ${tfs.length}</p>
    <h3 class="qtitle">${item.q}</h3>
    <div class="opts">
      <button class="opt-btn" data-v="true">
        <span class="key">T</span><span class="label">True</span>
      </button>
      <button class="opt-btn" data-v="false">
        <span class="key">F</span><span class="label">False</span>
      </button>
    </div>
    <div class="feedback" hidden></div>
  `;

  const buttons = card.querySelectorAll('.opt-btn');
  const feedback = card.querySelector('.feedback');

  function lock(){
    card.dataset.locked = 'true';
    buttons.forEach(b=>b.setAttribute('disabled',''));
  }

  buttons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if(card.dataset.locked === 'true') return; // one attempt
      const val = btn.dataset.v === "true";
      state.tf[idx] = val;

      // clear classes
      buttons.forEach(b=>b.classList.remove('correct','wrong'));

      // Always mark the correct button (green)
      const correctBtn = Array.from(buttons).find(b => (b.dataset.v === (item.answer ? "true" : "false")));
      correctBtn.classList.add('correct');

      const isCorrect = (val === item.answer);
      if(!isCorrect){
        // mark chosen wrong (red)
        btn.classList.add('wrong');
        feedback.hidden=false;
        feedback.innerHTML = `<b>Wrong ✖</b><br>Correct answer: <b>${item.answer ? 'True' : 'False'}</b><br>${item.explain}`;
      }else{
        feedback.hidden=false;
        feedback.innerHTML = `<b>Correct ✔</b><br>Answer: <b>${item.answer ? 'True' : 'False'}</b><br>${item.explain}`;
      }

      lock();
      recalc();
    });
  });

  tfGrid.appendChild(card);
});

// ----------- Render SAQs -----------
const saqGrid = document.getElementById('saqGrid');
saqs.forEach((item, idx)=>{
  const card = document.createElement('article');
  card.className='card qcard';
  card.dataset.type='saq';
  card.dataset.index = idx;
  card.innerHTML = `
    <h3 class="qtitle">${item.q}</h3>
    <textarea rows="4" placeholder="Type your answer..." style="width:100%;padding:12px;border-radius:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.14);color:var(--text);"></textarea>
    <div class="btnrow" style="margin-top:10px">
      <button class="primary" data-act="reveal">Reveal Answer</button>
      <button class="ghost" data-act="toggle">I was correct</button>
    </div>
    <div class="answer" hidden>${item.a}</div>
  `;

  const revealBtn = card.querySelector('[data-act="reveal"]');
  const toggleBtn = card.querySelector('[data-act="toggle"]');
  const answer = card.querySelector('.answer');

  revealBtn.addEventListener('click', ()=>{
    answer.hidden = !answer.hidden;
    revealBtn.textContent = answer.hidden ? "Reveal Answer" : "Hide Answer";
  });

  toggleBtn.addEventListener('click', ()=>{
    const now = !state.saq[idx];
    state.saq[idx] = now;
    toggleBtn.textContent = now ? "✓ Counted as correct" : "I was correct";
    toggleBtn.style.outline = now ? "2px solid rgba(34,197,94,.7)" : "none";
    recalc();
  });

  saqGrid.appendChild(card);
});

// ----------- Score + Reset -----------
function recalc(){
  const mcqScore = state.mcq.reduce((s,v,i)=>{
    if(v===null) return s;
    const card = document.querySelector(`.qcard[data-type="mcq"][data-index="${i}"]`);
    const feedback = card.querySelector('.feedback').textContent;
    return s + (feedback.startsWith("Correct") ? 1 : 0);
  },0);
  const tfScore = state.tf.reduce((s,v,i)=>{
    if(v===null) return s;
    const card = document.querySelector(`.qcard[data-type="tf"][data-index="${i}"]`);
    const feedback = card.querySelector('.feedback').textContent;
    return s + (feedback.startsWith("Correct") ? 1 : 0);
  },0);
  const saqScore = state.saq.filter(Boolean).length;
  const total = mcqScore + tfScore + saqScore;

  const ids = ["sMcq","sTf","sSaq","sTotal","sMcq2","sTf2","sSaq2","sTotal2"];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    if(id.includes('Mcq')) el.textContent = mcqScore;
    if(id.includes('Tf')) el.textContent = tfScore;
    if(id.includes('Saq')) el.textContent = saqScore;
    if(id.includes('Total')) el.textContent = total;
  });
}

document.getElementById('resetAll').addEventListener('click', ()=>{
  document.querySelectorAll('.qcard .feedback').forEach(f=>{f.hidden=true; f.textContent=''; f.innerHTML='';});
  document.querySelectorAll('.opt-btn').forEach(b=>{
    b.classList.remove('correct','wrong');
    b.removeAttribute('disabled');
  });
  document.querySelectorAll('.qcard[data-type="mcq"], .qcard[data-type="tf"]').forEach(c=>{c.dataset.locked='false';});
  document.querySelectorAll('.qcard[data-type="saq"] textarea').forEach(t=>t.value="");
  document.querySelectorAll('.qcard[data-type="saq"] .answer').forEach(a=>a.hidden=true);
  document.querySelectorAll('.qcard[data-type="saq"] [data-act="reveal"]').forEach(b=>b.textContent="Reveal Answer");
  document.querySelectorAll('.qcard[data-type="saq"] [data-act="toggle"]').forEach(b=>{b.textContent="I was correct"; b.style.outline="none";});

  state.mcq.fill(null); state.tf.fill(null); state.saq.fill(false);
  recalc();
});

recalc();
</script>
</body>
</html>
